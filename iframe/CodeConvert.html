<!doctype html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>狼黑工具 - 丝印代码转换</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
				font-family: 'Microsoft YaHei', sans-serif;
			}

			body {
				/* width: 720px;
            height: 640px; */
				width: 100%;
				height: 100vh;
				padding: 0px 15px 15px 15px;
				background-color: #f5f5f5;
			}

			.container {
				width: 100%;
				height: 100%;
				display: flex;
				flex-direction: column;
			}

			.header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				padding: 10px 0;
				border-bottom: 1px solid #ddd;
				margin-bottom: 15px;
			}

			.title {
				font-size: 20px;
				font-weight: bold;
				color: #333;
				display: flex;
				align-items: center;
				gap: 10px;
			}

			.version-tag {
				font-size: 12px;
				font-weight: normal;
				background-color: #e0e0e0;
				padding: 2px 6px;
				border-radius: 4px;
				color: #555;
			}

			.controls {
				display: flex;
				align-items: center;
				gap: 15px;
			}

			.select-all {
				display: flex;
				align-items: center;
				gap: 5px;
			}

			.execute-btn {
				padding: 8px 16px;
				background-color: #4caf50;
				color: white;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				font-size: 14px;
			}

			.execute-btn:hover {
				background-color: #45a049;
			}

			.execute-btn:disabled {
				background-color: #cccccc;
				cursor: not-allowed;
			}

			.table-container {
				flex: 1;
				overflow: auto;
				border: 1px solid #ddd;
				border-radius: 4px;
				background-color: white;
			}

			table {
				width: 100%;
				border-collapse: collapse;
			}

			th,
			td {
				padding: 10px;
				text-align: left;
				border-bottom: 1px solid #ddd;
			}

			th {
				background-color: #f2f2f2;
				font-weight: bold;
				position: sticky;
				top: 0;
			}

			tr:hover {
				background-color: #f9f9f9;
			}

			.checkbox-cell {
				text-align: center;
				width: 40px;
			}

			.status {
				margin-top: 10px;
				padding: 8px;
				border-radius: 4px;
				text-align: center;
				font-size: 14px;
			}

			.status.success {
				background-color: #dff0d8;
				color: #3c763d;
			}

			.status.error {
				background-color: #f2dede;
				color: #a94442;
			}

			.status.info {
				background-color: #d9edf7;
				color: #31708f;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div class="header">
				<div class="title">
					丝印代码转换工具
					<span id="versionTag" class="version-tag">检测中...</span>
				</div>
				只处理位号以C、R、L开头的元件
				<div class="controls">
					<div class="select-all">
						<input type="checkbox" id="selectAll" style="transform: scale(1.5)" />
						<label for="selectAll">全选</label>
					</div>
					<button id="executeBtn" class="execute-btn">执行</button>
				</div>
			</div>

			<div class="table-container">
				<table id="componentsTable">
					<thead>
						<tr>
							<th style="width: 50px; z-index: 1" class="checkbox-cell">修改</th>
							<th style="width: 100px">唯一ID</th>
							<th style="width: 80px">位号</th>
							<th style="width: 80px">代码/名称</th>
							<th style="width: 80px">转换值</th>
						</tr>
					</thead>
					<tbody id="tableBody"></tbody>
				</table>
			</div>

			<div id="status" class="status"></div>
		</div>

		<script>
			let componentsData = [];
			let jsonData = null;
			let componentsMap = null; // 指向实际的组件对象集合（V2指向根，V3指向components属性）
			let Page;
			let isV3 = false;

			// E96系列电阻代码映射表 (标准E96系列值)
			const E96_VALUES = {
				'01': 100,
				'02': 102,
				'03': 105,
				'04': 107,
				'05': 110,
				'06': 113,
				'07': 115,
				'08': 118,
				'09': 121,
				'10': 124,
				'11': 127,
				'12': 130,
				'13': 133,
				'14': 137,
				'15': 140,
				'16': 143,
				'17': 147,
				'18': 150,
				'19': 154,
				'20': 158,
				'21': 162,
				'22': 165,
				'23': 169,
				'24': 174,
				'25': 178,
				'26': 182,
				'27': 187,
				'28': 191,
				'29': 196,
				'30': 200,
				'31': 205,
				'32': 210,
				'33': 215,
				'34': 221,
				'35': 226,
				'36': 232,
				'37': 237,
				'38': 243,
				'39': 249,
				'40': 255,
				'41': 261,
				'42': 267,
				'43': 274,
				'44': 280,
				'45': 287,
				'46': 294,
				'47': 301,
				'48': 309,
				'49': 316,
				'50': 324,
				'51': 332,
				'52': 340,
				'53': 348,
				'54': 357,
				'55': 365,
				'56': 374,
				'57': 383,
				'58': 392,
				'59': 402,
				'60': 412,
				'61': 422,
				'62': 432,
				'63': 442,
				'64': 453,
				'65': 464,
				'66': 475,
				'67': 487,
				'68': 499,
				'69': 511,
				'70': 523,
				'71': 536,
				'72': 549,
				'73': 562,
				'74': 576,
				'75': 590,
				'76': 604,
				'77': 619,
				'78': 634,
				'79': 649,
				'80': 665,
				'81': 681,
				'82': 698,
				'83': 715,
				'84': 732,
				'85': 750,
				'86': 768,
				'87': 787,
				'88': 806,
				'89': 825,
				'90': 845,
				'91': 866,
				'92': 887,
				'93': 909,
				'94': 931,
				'95': 953,
				'96': 976,
			};

			// E96乘数字母映射
			const E96_MULTIPLIERS = {
				'Z': 0.001,
				'Y': 0.01,
				'X': 0.1,
				'A': 1,
				'B': 10,
				'C': 100,
				'D': 1000,
				'E': 10000,
				'F': 100000,
				'G': 1000000,
			};

			// 数据处理逻辑，根据是否转换成功决定是否勾选
			function processComponentsData() {
				componentsData = [];

				// 使用 componentsMap 替代 jsonData 进行遍历
				for (const key in componentsMap) {
					const component = componentsMap[key];

					// 确保有 props 属性 (防止读取到元数据)
					if (!component.props) continue;

					const designator = component.props.Designator;
					const name = component.props.Name;
					const uniqueId = component.props['Unique ID'];

					// 只处理位号以C、R、L开头的组件
					if (designator && /^[CRL]/i.test(designator) && !/(?:[MK]?Ω|[PNU]?F|[UM]?H|F)/i.test(name)) {
						const convertedValue = convertCodeToValue(name, designator[0]);

						// 判断是否成功转换：如果返回值与原值不同且不是null，则认为转换成功
						const isConverted = convertedValue !== name && convertedValue !== null;

						componentsData.push({
							uniqueId: uniqueId,
							designator: designator,
							name: name,
							value: convertedValue, // 直接使用转换后的值（可能是原值）
							shouldModify: isConverted, // 只有成功转换时才勾选
							modified: isConverted && uniqueId && uniqueId !== '', // 成功转换且有唯一ID才默认勾选
						});
					}
				}
			}

			// 根据位号开头处理
			function convertCodeToValue(code, type) {
				if (!code || !type) return null;

				const strCode = code.toString().toUpperCase();

				switch (type.toUpperCase()) {
					case 'R':
						return convertResistor(strCode);
					case 'C':
						return convertCapacitor(strCode);
					case 'L':
						return convertInductor(strCode);
					default:
						return code;
				}
			}

			// 电阻转换数值
			function convertResistor(code) {
				// E96系列电阻处理 (3位代码：2位数字 + 1位字母)
				if (code.length === 3 && /^\d{2}[A-Z]$/.test(code)) {
					const digits = code.substring(0, 2);
					const multiplierChar = code.substring(2, 3);

					if (E96_VALUES[digits] && E96_MULTIPLIERS[multiplierChar]) {
						const value = E96_VALUES[digits] * E96_MULTIPLIERS[multiplierChar];
						return formatValue(value, 'R');
					}
				}

				// 处理带单位字符的表示法 (如 4R7, 2K2, 0R5, R01)
				if (/^[0-9.]*[RKM][0-9.]*$/.test(code)) {
					const value = parseResistorWithUnit(code);
					if (value !== null) {
						return formatValue(value, 'R');
					}
				}

				// 纯数字处理
				let numericValue;
				if (/^\d+$/.test(code)) {
					if (code.length === 3) {
						// 3位数字：前2位有效数字，第3位是0的个数
						const firstTwo = code.substring(0, 2);
						const zeros = parseInt(code.substring(2, 3));
						numericValue = parseInt(firstTwo) * Math.pow(10, zeros);
					} else if (code.length === 4) {
						// 4位数字：前3位有效数字，第4位是0的个数 (如 1002 = 100 * 10^2 = 10K)
						const firstThree = code.substring(0, 3);
						const zeros = parseInt(code.substring(3, 4));
						numericValue = parseInt(firstThree) * Math.pow(10, zeros);
					} else {
						numericValue = parseFloat(code);
					}
				} else {
					numericValue = parseFloat(code);
				}

				if (isNaN(numericValue)) return code;
				return formatValue(numericValue, 'R');
			}

			// 电容转换数值
			function convertCapacitor(code) {
				let numericValue;

				// 处理带单位字符的表示法
				if (/^[0-9.]*[PNUM][0-9.]*[F]?$/.test(code)) {
					numericValue = parseCapacitorWithUnit(code);
				} else if (/^\d+$/.test(code)) {
					// 纯数字处理
					if (code.length === 3) {
						// 3位数字：前2位有效数字，第3位是0的个数（单位pF）
						const firstTwo = code.substring(0, 2);
						const zeros = parseInt(code.substring(2, 3));
						numericValue = parseInt(firstTwo) * Math.pow(10, zeros);
					} else {
						numericValue = parseFloat(code);
					}
				} else {
					numericValue = parseFloat(code);
				}

				if (isNaN(numericValue)) return code;
				return formatValue(numericValue, 'C');
			}

			// 电感转换数值
			function convertInductor(code) {
				let numericValue;

				// 处理带单位字符的表示法
				if (/^[0-9.]*[RNUMH][0-9.]*[H]?$/.test(code)) {
					numericValue = parseInductorWithUnit(code);
				} else if (/^\d+$/.test(code)) {
					// 纯数字处理
					if (code.length === 3) {
						// 3位数字：前2位有效数字，第3位是0的个数（单位uH）
						const firstTwo = code.substring(0, 2);
						const zeros = parseInt(code.substring(2, 3));
						numericValue = parseInt(firstTwo) * Math.pow(10, zeros);
					} else {
						numericValue = parseFloat(code);
					}
				} else {
					numericValue = parseFloat(code);
				}

				if (isNaN(numericValue)) return code;
				return formatValue(numericValue, 'L');
			}

			// 带单位的电阻解析
			function parseResistorWithUnit(code) {
				code = code.toUpperCase();

				// 处理零值
				if (code === '0' || code === '00' || code === '000' || code === '0R') {
					return 0;
				}

				// 处理 R 开头的情况（如 R01, R10, R005）
				if (code.startsWith('R') && code.length >= 2) {
					const numberPart = code.substring(1);
					const numericValue = parseFloat('0.' + numberPart);
					return isNaN(numericValue) ? null : numericValue;
				}

				// 处理带单位的情况（如 4R7, 2K2, 0R5, 0R05, 3R63）
				const match = code.match(/^([0-9]*\.?[0-9]*)[RKM]([0-9]*)$/);
				if (match) {
					const integerPart = match[1] || '0';
					const unitChar = match[0].includes('K') ? 'K' : match[0].includes('M') ? 'M' : 'R';
					const decimalPart = match[2] || '';

					// 构建完整数值
					let numericValue;
					if (decimalPart) {
						// 如果有小数部分，组合成完整数值
						numericValue = parseFloat(integerPart + '.' + decimalPart);
					} else {
						// 如果没有小数部分，直接使用整数部分
						numericValue = parseFloat(integerPart);
					}

					if (isNaN(numericValue)) return null;

					// 特殊处理：如果整数部分为0且有小数的格式（如0R5）
					if (integerPart === '0' && decimalPart) {
						numericValue = parseFloat('0.' + decimalPart);
					}

					// 应用单位乘数
					switch (unitChar) {
						case 'R':
							return numericValue;
						case 'K':
							return numericValue * 1000;
						case 'M':
							return numericValue * 1000000;
						default:
							return numericValue;
					}
				}

				return parseFloat(code);
			}

			// 带单位的电容解析
			function parseCapacitorWithUnit(code) {
				code = code.toUpperCase().replace('F', '');

				// 匹配数字部分和单位部分
				const match = code.match(/^([0-9.]*)([PNUM])([0-9.]*)$/);
				if (!match) return parseFloat(code);

				const numberPart = match[1] || '0';
				const unitChar = match[2];
				const decimalPart = match[3] || '';

				// 构建完整数值
				let numericValue;
				if (decimalPart) {
					numericValue = parseFloat(numberPart + '.' + decimalPart);
				} else {
					numericValue = parseFloat(numberPart);
				}

				if (isNaN(numericValue)) return null;

				// 根据单位字符应用乘数（转换为pF）
				switch (unitChar) {
					case 'P':
						return numericValue; // pF
					case 'N':
						return numericValue * 1000; // nF -> pF
					case 'U':
						return numericValue * 1000000; // uF -> pF
					case 'M':
						return numericValue * 1000000000; // mF -> pF
					default:
						return numericValue;
				}
			}

			// 带单位的电感解析
			function parseInductorWithUnit(code) {
				code = code.toUpperCase().replace('H', '');

				// 处理类似 R01, R10 的表示法（没有整数部分，2位小数）
				if (code.startsWith('R') && code.length >= 2) {
					const numberPart = code.substring(1);
					const numericValue = parseFloat('0.' + numberPart);
					// 修正：R01 = 0.01uH = 10nH，不是100mH
					return isNaN(numericValue) ? null : numericValue; // 返回uH值
				}

				// 匹配数字部分和单位部分
				const match = code.match(/^([0-9.]*)([RNUMH])([0-9.]*)$/);
				if (!match) return parseFloat(code);

				const numberPart = match[1] || '0';
				const unitChar = match[2];
				const decimalPart = match[3] || '';

				// 构建完整数值
				let numericValue;
				if (decimalPart) {
					numericValue = parseFloat(numberPart + '.' + decimalPart);
				} else {
					numericValue = parseFloat(numberPart);
				}

				if (isNaN(numericValue)) return null;

				// 根据单位字符应用乘数（转换为uH）
				switch (unitChar) {
					case 'R':
					case 'U':
						return numericValue; // uH
					case 'N':
						return numericValue * 0.001; // nH -> uH
					case 'M':
						return numericValue * 1000; // mH -> uH
					case 'H':
						return numericValue * 1000000; // H -> uH
					default:
						return numericValue;
				}
			}

			// 格式化加单位
			function formatValue(value, type) {
				if (value === undefined || value === null || isNaN(value)) return null;

				// 特殊处理零值
				if (value === 0) {
					switch (type) {
						case 'R':
							return '0Ω';
						case 'C':
							return '0pF';
						case 'L':
							return '0uH';
						default:
							return '0';
					}
				}

				const units = {
					'R': [
						{ unit: 'mΩ', factor: 0.001 },
						{ unit: 'Ω', factor: 1 },
						{ unit: 'KΩ', factor: 1000 },
						{ unit: 'MΩ', factor: 1000000 },
					],
					'C': [
						{ unit: 'pF', factor: 1 },
						{ unit: 'nF', factor: 1000 },
						{ unit: 'uF', factor: 1000000 },
						{ unit: 'mF', factor: 1000000000 },
						{ unit: 'F', factor: 1000000000000 },
					],
					'L': [
						{ unit: 'nH', factor: 0.001 },
						{ unit: 'uH', factor: 1 },
						{ unit: 'mH', factor: 1000 },
						{ unit: 'H', factor: 1000000 },
					],
				};

				const typeUnits = units[type];
				if (!typeUnits) return value.toString();

				// 找到最合适的单位
				let bestUnit = typeUnits[0];
				const absValue = Math.abs(value);

				for (let i = typeUnits.length - 1; i >= 0; i--) {
					if (absValue >= typeUnits[i].factor || i === 0) {
						bestUnit = typeUnits[i];
						break;
					}
				}

				const formattedValue = value / bestUnit.factor;

				// 使用Number来去除不必要的尾随零
				const displayValue = Number(formattedValue.toFixed(3)).toString();

				return displayValue + bestUnit.unit;
			}

			// 渲染表格
			function renderTable() {
				const tableBody = document.getElementById('tableBody');
				tableBody.innerHTML = '';

				// 检测重复的唯一ID
				const uniqueIdCount = {};
				componentsData.forEach((component) => {
					if (component.uniqueId && component.uniqueId !== '') {
						uniqueIdCount[component.uniqueId] = (uniqueIdCount[component.uniqueId] || 0) + 1;
					}
				});

				componentsData.forEach((component, index) => {
					const row = document.createElement('tr');

					// 修改复选框
					const modifyCell = document.createElement('td');
					modifyCell.className = 'checkbox-cell';
					const modifyCheckbox = document.createElement('input');
					modifyCheckbox.type = 'checkbox';

					// 检查是否有重复的唯一ID
					const hasDuplicateUniqueId = component.uniqueId && component.uniqueId !== '' && uniqueIdCount[component.uniqueId] > 1;

					// 如果有重复值，不勾选
					if (hasDuplicateUniqueId) {
						modifyCheckbox.checked = false;
					} else {
						modifyCheckbox.checked = component.modified && component.uniqueId && component.uniqueId !== '';
						modifyCheckbox.disabled = !component.uniqueId || component.uniqueId === '';
					}

					modifyCheckbox.dataset.index = index;
					modifyCheckbox.style.transform = 'scale(1.5)';
					modifyCheckbox.addEventListener('change', function () {
						if (component.uniqueId && component.uniqueId !== '' && !hasDuplicateUniqueId) {
							componentsData[index].modified = this.checked;
						}
						updateSelectAllCheckbox();
					});
					modifyCell.appendChild(modifyCheckbox);
					row.appendChild(modifyCell);

					// 唯一ID
					const uniqueIdCell = document.createElement('td');
					uniqueIdCell.textContent = component.uniqueId || '空';

					// 设置唯一ID单元格样式
					if (!component.uniqueId || component.uniqueId === '') {
						// 空值：红色加粗
						uniqueIdCell.style.color = 'red';
						uniqueIdCell.style.fontWeight = 'bold';
					} else if (hasDuplicateUniqueId) {
						// 重复值：红色加粗
						uniqueIdCell.style.color = 'red';
						uniqueIdCell.style.fontWeight = 'bold';
						uniqueIdCell.title = '重复的唯一ID'; // 添加提示
					}

					row.appendChild(uniqueIdCell);

					// 位号
					const designatorCell = document.createElement('td');
					designatorCell.textContent = component.designator;
					row.appendChild(designatorCell);

					// 代码/名称
					const nameCell = document.createElement('td');
					nameCell.textContent = component.name;
					row.appendChild(nameCell);

					// 值
					const valueCell = document.createElement('td');
					valueCell.textContent = component.value;
					if (component.shouldModify) {
						valueCell.style.color = '#4CAF50';
						valueCell.style.fontWeight = 'bold';
					}
					row.appendChild(valueCell);

					tableBody.appendChild(row);
				});

				updateSelectAllCheckbox();
			}

			// 全选/取消全选
			function toggleSelectAll() {
				const selectAll = document.getElementById('selectAll').checked;
				componentsData.forEach((component) => {
					if (component.shouldModify) {
						component.modified = selectAll;
					}
				});
				renderTable();
			}

			// 更新全选复选框状态
			function updateSelectAllCheckbox() {
				const selectAllCheckbox = document.getElementById('selectAll');
				const modifiableComponents = componentsData.filter((c) => c.shouldModify);
				const selectedComponents = modifiableComponents.filter((c) => c.modified);

				if (selectedComponents.length === 0) {
					selectAllCheckbox.checked = false;
					selectAllCheckbox.indeterminate = false;
				} else if (selectedComponents.length === modifiableComponents.length) {
					selectAllCheckbox.checked = true;
					selectAllCheckbox.indeterminate = false;
				} else {
					selectAllCheckbox.checked = false;
					selectAllCheckbox.indeterminate = true;
				}
			}

			// 执行转换
			async function executeConversion() {
				try {
					let modifiedCount = 0;

					// 使用 componentsMap 遍历查找并更新
					for (const component of componentsData) {
						if (component.modified && component.shouldModify) {
							// 在映射表中查找对应组件
							for (const key in componentsMap) {
								const mapComponent = componentsMap[key];
								if (mapComponent && mapComponent.props && mapComponent.props['Unique ID'] === component.uniqueId) {
									// 更新Name和Value字段
									mapComponent.props.Name = component.value;
									mapComponent.props.Value = component.value;
									modifiedCount++;
									break;
								}
							}
						}
					}

					// 注意：由于 componentsMap 是引用 jsonData 的一部分（或全部），
					// 修改 componentsMap 会自动更新 jsonData。
					// 所以这里直接 stringify jsonData 即可。

					const listjson = JSON.stringify(jsonData);

					console.log(Page);
					if (Page === 'PCB') {
						await eda.pcb_Net.setNetlist('JLCEDA', listjson);
					} else {
						await eda.sch_Netlist.setNetlist('JLCEDA', listjson);
					}

					// showStatus(`成功转换并更新了 ${modifiedCount} 个组件的值`, "success");
					eda.sys_IFrame.closeIFrame('CodeConvert'); //关闭窗口
				} catch (error) {
					console.error('执行转换失败:', error);
					showStatus('转换失败: ' + error.message, 'error');
				}
			}

			// 显示状态信息
			function showStatus(message, type) {
				const statusElement = document.getElementById('status');
				statusElement.textContent = message;
				statusElement.className = 'status ' + type;
			}

			// 初始化函数
			async function initialize() {
				const verTag = document.getElementById('versionTag');

				// 检测版本
				try {
					if (typeof eda !== 'undefined' && eda.sys_Environment && eda.sys_Environment.getEditorCurrentVersion) {
						const version = eda.sys_Environment.getEditorCurrentVersion();
						console.log('当前EDA版本:', version);
						if (version && version.toString().startsWith('3')) {
							isV3 = true;
							verTag.textContent = 'V3模式';
						} else {
							verTag.textContent = 'V2模式';
						}
					} else {
						verTag.textContent = 'V2模式 (默认)';
					}
				} catch (e) {
					console.warn('版本检测失败，默认使用V2模式', e);
					verTag.textContent = 'V2模式';
				}

				try {
					let getNetlist;
					let NetList;
					try {
						getNetlist = await eda.pcb_ManufactureData.getNetlistFile('JLCEDA');
						NetList = await getNetlist.text();
						Page = 'PCB';
					} catch (error) {
						getNetlist = await eda.sch_ManufactureData.getNetlistFile('JLCEDA');
						NetList = await getNetlist.text();
						Page = 'SCH';
					}
					// console.log(NetList);
					jsonData = JSON.parse(NetList);

					// 关键点：确定组件数据源
					if (isV3 && jsonData.components) {
						componentsMap = jsonData.components;
					} else {
						// V2 或 V3结构不匹配回退
						componentsMap = jsonData;
					}

					// 改进的检查唯一ID是否为空或者重复的代码
					let hasEmptyUniqueId = false;
					const seenIds = {};

					// 使用 componentsMap 进行检查
					for (const key in componentsMap) {
						const component = componentsMap[key];
						if (!component.props) continue; // 跳过非组件项

						const uniqueId = component.props['Unique ID'];

						// 检查是否为空
						if (!uniqueId || uniqueId === '') {
							hasEmptyUniqueId = true;
							break;
						}

						// 检查是否重复（非空的情况下）
						if (uniqueId && uniqueId !== '') {
							if (seenIds[uniqueId]) {
								hasEmptyUniqueId = true;
								break;
							} else {
								seenIds[uniqueId] = true;
							}
						}
					}

					// 处理数据并显示表格
					processComponentsData();
					renderTable();

					// 绑定事件
					document.getElementById('selectAll').addEventListener('change', toggleSelectAll);
					document.getElementById('executeBtn').addEventListener('click', executeConversion);

					if (hasEmptyUniqueId) {
						showStatus('部分元件的唯一ID为空/重复，可以在菜单栏-设计-重置唯一ID，否则会出现异常', 'error');
					} else {
						showStatus(`数据加载成功 (${isV3 ? 'V3' : 'V2'})，请仔细检查后，选择要转换的组件`, 'info');
					}
				} catch (error) {
					console.error('初始化失败:', error);
					showStatus('数据加载失败: ' + error.message, 'error');
				}
			}

			// 页面加载完成后初始化
			document.addEventListener('DOMContentLoaded', async function () {
				await initialize();
			});
		</script>
	</body>
</html>
